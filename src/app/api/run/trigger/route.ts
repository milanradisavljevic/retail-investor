/**
 * API Route: Manual Run Trigger
 * Allows triggering Russell 2000 runs from the GUI
 */

import { NextRequest, NextResponse } from 'next/server';
import { spawn } from 'child_process';
import path from 'path';

export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

interface LiveRunFilterConfig {
  excludeCryptoMining?: boolean;
  excludeDefense?: boolean;
  excludeFossilFuels?: boolean;
  minMarketCap?: number | null;
  minLiquidity?: number | null;
  maxVolatility?: number | null;
}

interface TriggerRunRequest {
  universe?: string;
  preset?: string | null;
  filters?: LiveRunFilterConfig;
}

interface TriggerRunResponse {
  success: boolean;
  message: string;
  runId?: string;
  estimatedDuration?: string;
  error?: string;
}

/**
 * Calculate estimated duration based on symbol count
 * Formula: symbols Ã— 0.05 = minutes
 */
function estimateDuration(symbolCount: number): string {
  const minutes = Math.floor(symbolCount * 0.05);

  if (minutes === 0) return '~15 seconds';
  if (minutes < 1) return '~1 minute';
  if (minutes >= 60) {
    const hours = Math.floor(minutes / 60);
    const mins = minutes % 60;
    return mins > 0 ? `~${hours}h ${mins}m` : `~${hours}h`;
  }
  return `~${minutes} minutes`;
}

/**
 * Load universe config to get symbol count
 */
function getUniverseSymbolCount(universeId: string): number {
  try {
    const fs = require('fs');
    const universePath = path.join(process.cwd(), 'config', 'universes', `${universeId}.json`);
    if (fs.existsSync(universePath)) {
      const universeConfig = JSON.parse(fs.readFileSync(universePath, 'utf-8'));
      return universeConfig.symbols?.length || 0;
    }
  } catch (error) {
    console.warn(`Could not load universe ${universeId}:`, error);
  }
  return 0;
}

export async function POST(request: NextRequest): Promise<NextResponse<TriggerRunResponse>> {
  try {
    const body = await request.json() as TriggerRunRequest;
    const universe = body.universe || 'russell2000_full_yf';
    const preset = body.preset;
    const filters = body.filters;

    // Calculate estimated duration based on actual symbol count
    const symbolCount = getUniverseSymbolCount(universe);
    const estimatedDuration = symbolCount > 0
      ? estimateDuration(symbolCount)
      : '~5-10 minutes';

    // Run the daily script in background
    const scriptPath = path.join(process.cwd(), 'scripts', 'run_daily.ts');

    // Build command args
    const args = ['tsx', scriptPath, `--universe=${universe}`];
    if (preset) {
      args.push(`--preset=${preset}`);
    }
    if (filters) {
      // Pass filters as JSON string
      args.push(`--filters=${JSON.stringify(filters)}`);
    }

    return new Promise((resolve) => {
      const child = spawn('npx', args, {
        detached: true,
        stdio: 'ignore',
        cwd: process.cwd(),
      });

      // Don't wait for the process
      child.unref();

      const message = preset
        ? `Run triggered for ${universe} with preset ${preset}`
        : `Run triggered for ${universe}`;

      resolve(
        NextResponse.json({
          success: true,
          message,
          estimatedDuration,
          runId: 'pending', // Will be generated by the script
        })
      );
    });
  } catch (error) {
    console.error('Failed to trigger run:', error);
    return NextResponse.json(
      {
        success: false,
        message: 'Failed to trigger run',
        error: error instanceof Error ? error.message : 'Unknown error',
      },
      { status: 500 }
    );
  }
}

// GET endpoint to check if a run is currently in progress
export async function GET(): Promise<NextResponse> {
  // This is a simplified version - in production you'd check for a lock file or process
  return NextResponse.json({
    isRunning: false,
    message: 'No run status tracking implemented yet',
  });
}
